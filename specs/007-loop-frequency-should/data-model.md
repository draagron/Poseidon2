# Data Model: WebSocket Loop Frequency Logging

**Feature**: WebSocket Loop Frequency Logging (R007)
**Date**: 2025-10-10
**Status**: Complete

## Overview

This document defines the data structures and categorization logic for WebSocket logging of loop frequency metrics. The feature reuses existing data structures (uint32_t frequency from LoopPerformanceMonitor) and adds minimal new logic for log level determination and JSON formatting.

---

## Data Structures

### 1. Loop Frequency Value

**Type**: `uint32_t` (unsigned 32-bit integer)
**Unit**: Hertz (Hz)
**Source**: `systemMetrics->getLoopFrequency()` (R006 - LoopPerformanceMonitor)

**Range**:
- **Minimum**: 0 Hz (no measurement yet, first 5 seconds)
- **Typical**: 100-500 Hz (ESP32 with ReactESP event loops)
- **Maximum**: Theoretical 10,000 Hz (unrealistic for ESP32)
- **Practical Max**: 2,000 Hz (upper threshold for normal operation)

**Value Interpretation**:
```cpp
uint32_t frequency = systemMetrics->getLoopFrequency();

if (frequency == 0) {
    // No measurement yet (first 5 seconds after boot)
    // Still log with placeholder value
} else if (frequency >= 10 && frequency <= 2000) {
    // Normal operation
} else {
    // Abnormal frequency (warning condition)
}
```

---

### 2. Log Message JSON Schema

**Format**: Minimal JSON object with single field

**Schema Definition**:
```json
{
  "frequency": <uint32_t>
}
```

**Examples**:
```json
// Normal frequency
{"frequency": 212}

// Low frequency (warning)
{"frequency": 5}

// High frequency (warning)
{"frequency": 2500}

// No measurement yet
{"frequency": 0}
```

**Field Specifications**:
- **Key**: `"frequency"` (string literal)
- **Value**: Numeric (no quotes), uint32_t range (0 to 4,294,967,295)
- **Size**: 19-25 bytes depending on value
  - `{"frequency":0}` = 15 bytes
  - `{"frequency":212}` = 19 bytes
  - `{"frequency":9999}` = 20 bytes

**String Construction** (C++):
```cpp
uint32_t frequency = 212;
String data = String("{\"frequency\":") + frequency + "}";
// Result: "{\"frequency\":212}"
```

---

### 3. Log Metadata

**Provided by WebSocketLogger** (not user-controlled):

| Field | Value | Type | Source |
|-------|-------|------|--------|
| timestamp | millis() | uint32_t | WebSocketLogger |
| level | "DEBUG" or "WARN" | string | User logic |
| component | "Performance" | string | User code |
| event | "LOOP_FREQUENCY" | string | User code |
| data | `{"frequency":XXX}` | JSON | User code |

**Complete Log Message Structure** (generated by WebSocketLogger):
```json
{
  "timestamp": 12345678,
  "level": "DEBUG",
  "component": "Performance",
  "event": "LOOP_FREQUENCY",
  "data": {"frequency": 212}
}
```

**Size Estimate**:
- Timestamp: 10-15 bytes (`"timestamp":12345678,`)
- Level: 8-20 bytes (`"level":"DEBUG"` or `"level":"WARN"`)
- Component: 30 bytes (`"component":"Performance",`)
- Event: 35 bytes (`"event":"LOOP_FREQUENCY",`)
- Data: 25-30 bytes (`"data":{"frequency":212}`)
- Structure overhead: 10 bytes (`{`, `}`, commas, newlines)
- **Total**: ~130-150 bytes ✅ (well under 200 byte limit, NFR-011)

---

### 4. Frequency Categories (Log Level Determination)

**Purpose**: Determine appropriate log level based on frequency value

**Categories**:

| Category | Frequency Range | Log Level | Reason |
|----------|----------------|-----------|--------|
| **No Measurement** | 0 Hz | DEBUG | First 5 seconds, expected condition |
| **Normal** | 10-2000 Hz | DEBUG | Typical operation, informational |
| **Low Warning** | 1-9 Hz | WARN | Potential system overload or hang |
| **High Warning** | > 2000 Hz | WARN | Unrealistic, possible measurement error |

**Decision Logic** (C++):
```cpp
LogLevel determineLogLevel(uint32_t frequency) {
    if (frequency == 0) {
        return LogLevel::DEBUG;  // No measurement yet
    }
    if (frequency >= 10 && frequency <= 2000) {
        return LogLevel::DEBUG;  // Normal operation
    }
    return LogLevel::WARN;  // Abnormal (< 10 Hz or > 2000 Hz)
}
```

**Inline Implementation** (for lambda):
```cpp
LogLevel level = (frequency > 0 && frequency >= 10 && frequency <= 2000)
                 ? LogLevel::DEBUG : LogLevel::WARN;
```

**Edge Cases**:
- **0 Hz**: DEBUG (explicit check, expected during startup)
- **10 Hz**: DEBUG (lower boundary of normal)
- **2000 Hz**: DEBUG (upper boundary of normal)
- **9 Hz**: WARN (just below threshold)
- **2001 Hz**: WARN (just above threshold)

---

## Data Flow

### High-Level Flow

```
1. ReactESP Event Loop (5-second interval)
    ↓
2. Get Frequency: systemMetrics->getLoopFrequency()
    ↓ (uint32_t)
3. Determine Log Level: DEBUG or WARN
    ↓ (LogLevel)
4. Format JSON: String("{\"frequency\":") + frequency + "}"
    ↓ (String)
5. Broadcast Log: logger.broadcastLog(level, "Performance", "LOOP_FREQUENCY", data)
    ↓
6. WebSocketLogger: Add metadata (timestamp, level string)
    ↓
7. Broadcast to All WebSocket Clients
```

### Detailed Implementation Flow

**Step 1: Trigger** (every 5 seconds)
```cpp
app.onRepeat(DISPLAY_STATUS_INTERVAL_MS, []() {
    // Existing display update
    if (displayManager != nullptr) {
        displayManager->renderStatusPage();
    }

    // NEW: WebSocket logging
    if (systemMetrics != nullptr) {
        // Step 2-5 happen here
    }
});
```

**Step 2: Get Frequency**
```cpp
uint32_t frequency = systemMetrics->getLoopFrequency();
// Returns: 0 (no measurement), 10-2000 (normal), or outside range (abnormal)
```

**Step 3: Determine Log Level**
```cpp
LogLevel level = (frequency > 0 && frequency >= 10 && frequency <= 2000)
                 ? LogLevel::DEBUG : LogLevel::WARN;
```

**Step 4: Format JSON**
```cpp
String data = String("{\"frequency\":") + frequency + "}";
// Example result: "{\"frequency\":212}"
```

**Step 5: Broadcast Log**
```cpp
logger.broadcastLog(level, F("Performance"), F("LOOP_FREQUENCY"), data);
```

**Step 6-7: WebSocketLogger Handles**
- Constructs full JSON message with metadata
- Broadcasts to all connected WebSocket clients
- Silent failure if no clients (graceful degradation)

---

## Memory Footprint

### Static Allocation

**Global Variables**: None (reuses existing `systemMetrics`, `logger`)
**New Constants**: None
**Total Static**: 0 bytes ✅

### Stack Allocation (per log emission)

**Local Variables in Lambda**:
- `frequency` (uint32_t): 4 bytes
- `level` (LogLevel enum): 1 byte (optimized to single byte)
- `data` (String object): 8 bytes (pointer + length)
- Padding: 3 bytes (alignment)
- **Total Stack**: ~16 bytes ✅

**WebSocketLogger Stack** (during broadcastLog call):
- Parameters: ~16 bytes
- Internal buffers: ~32 bytes
- **Total**: ~48 bytes ✅

**Combined Stack Usage**: ~64 bytes (well within 8KB task limit)

### Heap Allocation (temporary)

**String `data` Heap**:
- JSON string: 15-25 bytes (depends on frequency value)
- String overhead: 4 bytes (capacity, null terminator)
- **Total**: ~20-30 bytes (freed after broadcast) ✅

**WebSocketLogger Internal** (during broadcast):
- Message construction: ~100 bytes (temporary)
- Freed immediately after transmission
- **Total**: ~100 bytes (transient) ✅

**Peak Heap Usage**: ~130 bytes (worst case, freed in <1ms)

### Flash Impact

**New Code**:
- Lambda function body: ~300 bytes (compiled)
- String formatting: ~100 bytes (inline)
- Log level logic: ~50 bytes (inline conditional)
- **Total Flash**: ~450-500 bytes ✅

---

## Data Validation

### Input Validation

**Frequency Value** (from systemMetrics->getLoopFrequency()):
- **Source**: LoopPerformanceMonitor (R006)
- **Validation**: Already validated in R006
- **Range**: 0 to UINT32_MAX (4,294,967,295)
- **No Additional Validation Needed**: Value is always valid uint32_t

### Output Validation

**JSON Formatting**:
- **Risk**: String construction could fail if OOM
- **Mitigation**: Heap usage is minimal (~30 bytes), checked by ESP32
- **Fallback**: WebSocketLogger silently fails, system continues (FR-059)

**Log Emission**:
- **Risk**: WebSocket server not initialized or no clients
- **Mitigation**: WebSocketLogger checks `hasClients()` internally
- **Result**: Silent no-op if no clients (graceful degradation)

---

## Testing Data

### Unit Test Cases (JSON Formatting)

**Test 1: Normal Frequency**
- Input: `frequency = 212`
- Expected: `"{\"frequency\":212}"`
- Log Level: `LogLevel::DEBUG`

**Test 2: Zero Frequency (No Measurement)**
- Input: `frequency = 0`
- Expected: `"{\"frequency\":0}"`
- Log Level: `LogLevel::DEBUG`

**Test 3: Low Frequency (Warning)**
- Input: `frequency = 5`
- Expected: `"{\"frequency\":5}"`
- Log Level: `LogLevel::WARN`

**Test 4: High Frequency (Warning)**
- Input: `frequency = 2500`
- Expected: `"{\"frequency\":2500}"`
- Log Level: `LogLevel::WARN`

**Test 5: Boundary (Lower Normal)**
- Input: `frequency = 10`
- Expected: `"{\"frequency\":10}"`
- Log Level: `LogLevel::DEBUG`

**Test 6: Boundary (Upper Normal)**
- Input: `frequency = 2000`
- Expected: `"{\"frequency\":2000}"`
- Log Level: `LogLevel::DEBUG`

**Test 7: Boundary (Just Below Normal)**
- Input: `frequency = 9`
- Expected: `"{\"frequency\":9}"`
- Log Level: `LogLevel::WARN`

**Test 8: Boundary (Just Above Normal)**
- Input: `frequency = 2001`
- Expected: `"{\"frequency\":2001}"`
- Log Level: `LogLevel::WARN`

### Integration Test Cases (Log Emission)

**Test 1: Log Emission with Normal Frequency**
- Setup: MockSystemMetrics returns 212 Hz
- Action: Trigger 5-second event loop
- Assert: broadcastLog called with DEBUG, "Performance", "LOOP_FREQUENCY", `{"frequency":212}`

**Test 2: Log Emission with Abnormal Frequency**
- Setup: MockSystemMetrics returns 5 Hz
- Action: Trigger 5-second event loop
- Assert: broadcastLog called with WARN, "Performance", "LOOP_FREQUENCY", `{"frequency":5}`

**Test 3: 5-Second Timing**
- Setup: Mock millis() to advance 5000ms
- Action: Simulate event loop execution
- Assert: broadcastLog called exactly once per 5 seconds

**Test 4: Multiple Clients**
- Setup: WebSocketLogger with 3 mock clients
- Action: Trigger log emission
- Assert: All 3 clients receive message

**Test 5: Graceful Degradation (No Clients)**
- Setup: WebSocketLogger with 0 clients
- Action: Trigger log emission
- Assert: No crash, system continues

---

## Schema Evolution

**Current Version**: 1.0

**Future Considerations** (Out of Scope for R007):

**Potential Addition 1: Unit Field** (REJECTED for R007)
```json
{"frequency": 212, "unit": "Hz"}
```
- **Reason Rejected**: Redundant (Hz is implied), increases message size

**Potential Addition 2: Status Field** (REJECTED for R007)
```json
{"frequency": 212, "status": "normal"}
```
- **Reason Rejected**: Log level already indicates status (DEBUG vs WARN)

**Potential Addition 3: Thresholds** (REJECTED for R007)
```json
{"frequency": 212, "min": 10, "max": 2000}
```
- **Reason Rejected**: Thresholds are static, no need to repeat every log

**Decision**: Keep minimal schema (single field) for R007. Future features can extend if needed.

---

## Conclusion

**Data Model Complexity**: ✅ **MINIMAL** - Single uint32_t value, single JSON field

**Memory Impact**: ✅ **NEGLIGIBLE** - 0 bytes static, ~16 bytes stack, ~30 bytes heap (temporary)

**Validation Needed**: ✅ **NONE** - Input pre-validated by R006, output format is trivial

**Schema Stability**: ✅ **STABLE** - Minimal schema unlikely to change, easy to extend if needed

---

**Data Model Version**: 1.0 | **Last Updated**: 2025-10-10
