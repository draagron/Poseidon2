<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Source Statistics - Poseidon2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #0a0e27;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        h1 {
            font-size: 2rem;
            color: #4fc3f7;
            font-weight: 600;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background-color: #1a1f3a;
            border-radius: 8px;
            border: 2px solid #2a3f5f;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #f44336;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background-color: #4caf50;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-text {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .summary-card {
            background-color: #1a1f3a;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #2a3f5f;
        }

        .summary-card h3 {
            font-size: 0.85rem;
            color: #9e9e9e;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .summary-card .value {
            font-size: 2rem;
            color: #4fc3f7;
            font-weight: 600;
        }

        .category-section {
            margin-bottom: 30px;
            background-color: #1a1f3a;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid #2a3f5f;
        }

        .category-header {
            background-color: #2a3f5f;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .category-header:hover {
            background-color: #3a4f6f;
        }

        .category-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #4fc3f7;
        }

        .category-badge {
            background-color: #4fc3f7;
            color: #0a0e27;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .category-content {
            display: none;
        }

        .category-content.active {
            display: block;
        }

        .sources-table {
            width: 100%;
            border-collapse: collapse;
        }

        .sources-table thead {
            background-color: #0f1729;
        }

        .sources-table th {
            text-align: left;
            padding: 15px 20px;
            font-size: 0.85rem;
            color: #9e9e9e;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .sources-table tbody tr {
            border-bottom: 1px solid #2a3f5f;
            transition: background-color 0.2s;
        }

        .sources-table tbody tr:hover {
            background-color: #1f2640;
        }

        .sources-table tbody tr:last-child {
            border-bottom: none;
        }

        .sources-table td {
            padding: 15px 20px;
            font-size: 0.95rem;
        }

        .source-id {
            font-family: 'Courier New', monospace;
            color: #fff;
            font-weight: 500;
        }

        .message-type {
            color: #9e9e9e;
            font-family: 'Courier New', monospace;
        }

        .protocol-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .protocol-nmea2000 {
            background-color: rgba(76, 175, 80, 0.2);
            color: #81c784;
            border: 1px solid #81c784;
        }

        .protocol-nmea0183 {
            background-color: rgba(33, 150, 243, 0.2);
            color: #64b5f6;
            border: 1px solid #64b5f6;
        }

        .frequency {
            font-weight: 600;
            color: #4fc3f7;
        }

        .time-since {
            color: #9e9e9e;
        }

        .staleness-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .staleness-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            box-shadow: 0 0 8px currentColor;
        }

        .staleness-dot.fresh {
            background-color: #4caf50;
            color: #4caf50;
        }

        .staleness-dot.stale {
            background-color: #f44336;
            color: #f44336;
            animation: pulse 2s infinite;
        }

        .staleness-text {
            font-size: 0.85rem;
            font-weight: 600;
        }

        .staleness-text.fresh {
            color: #4caf50;
        }

        .staleness-text.stale {
            color: #f44336;
        }

        /* Device Info Styling */
        .device-info-cell {
            font-size: 0.9rem;
            max-width: 250px;
        }

        .device-info-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .device-primary {
            color: #fff;
            font-size: 0.95rem;
        }

        .device-primary strong {
            color: #4fc3f7;
        }

        .device-secondary {
            color: #9e9e9e;
            font-size: 0.8rem;
            font-family: 'Courier New', monospace;
        }

        .device-description {
            color: #9e9e9e;
            font-style: italic;
        }

        .device-discovering {
            color: #ff9800;
            font-size: 0.85rem;
        }

        .device-timeout {
            color: #f44336;
            font-size: 0.85rem;
        }

        .device-unknown {
            color: #616161;
        }

        .empty-state {
            padding: 60px 20px;
            text-align: center;
            color: #9e9e9e;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.3;
        }

        .empty-state-text {
            font-size: 1.1rem;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .summary {
                grid-template-columns: repeat(2, 1fr);
            }

            .sources-table {
                font-size: 0.85rem;
            }

            .sources-table th,
            .sources-table td {
                padding: 10px;
            }

            /* Stack table on mobile */
            .sources-table thead {
                display: none;
            }

            .sources-table tbody tr {
                display: flex;
                flex-direction: column;
                padding: 15px;
                border: 1px solid #2a3f5f;
                border-radius: 8px;
                margin-bottom: 10px;
            }

            .sources-table tbody tr td {
                padding: 5px 0;
                border: none;
            }

            .sources-table tbody tr td:before {
                content: attr(data-label);
                font-weight: 600;
                color: #9e9e9e;
                display: inline-block;
                width: 120px;
            }
        }

        @media (max-width: 480px) {
            .summary {
                grid-template-columns: 1fr;
            }
        }

        /* Loading animation */
        .loading {
            text-align: center;
            padding: 40px;
            color: #9e9e9e;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #2a3f5f;
            border-top-color: #4fc3f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Source Statistics</h1>
            <div class="connection-status">
                <div class="status-indicator" id="connectionIndicator"></div>
                <span class="status-text" id="connectionText">Connecting...</span>
            </div>
        </header>

        <div class="summary">
            <div class="summary-card">
                <h3>Total Sources</h3>
                <div class="value" id="totalSources">0</div>
            </div>
            <div class="summary-card">
                <h3>Active Sources</h3>
                <div class="value" id="activeSources">0</div>
            </div>
            <div class="summary-card">
                <h3>Stale Sources</h3>
                <div class="value" id="staleSources">0</div>
            </div>
            <div class="summary-card">
                <h3>Active Categories</h3>
                <div class="value" id="activeCategories">0</div>
            </div>
        </div>

        <div class="loading" id="loadingIndicator">
            <div class="loading-spinner"></div>
            <div>Waiting for data...</div>
        </div>

        <div id="categoriesContainer"></div>
    </div>

    <script>
        // Configuration
        const ESP32_IP = window.location.hostname;
        const WS_ENDPOINT = `ws://${ESP32_IP}/source-stats`;

        // Global state
        let ws = null;
        let sources = {};
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 10;
        const RECONNECT_DELAY = 3000;

        // Category display names
        const categoryNames = {
            GPS: 'GPS & Position',
            COMPASS: 'Compass & Heading',
            DST: 'Depth, Speed & Trip',
            WIND: 'Wind',
            ENGINE: 'Engine',
            BATTERY: 'Battery',
            RUDDER: 'Rudder',
            ONEWIRESENSORS: '1-Wire Sensors',
            SHOREPOWER: 'Shore Power'
        };

        // Initialize WebSocket connection
        function connectWebSocket() {
            console.log('Connecting to WebSocket:', WS_ENDPOINT);
            updateConnectionStatus('Connecting...', false);

            ws = new WebSocket(WS_ENDPOINT);

            ws.onopen = () => {
                console.log('WebSocket connected');
                updateConnectionStatus('Connected', true);
                reconnectAttempts = 0;
            };

            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    handleWebSocketMessage(message);
                } catch (error) {
                    console.error('Failed to parse WebSocket message:', error);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateConnectionStatus('Error', false);
            };

            ws.onclose = () => {
                console.log('WebSocket closed');
                updateConnectionStatus('Disconnected', false);
                attemptReconnect();
            };
        }

        // Handle incoming WebSocket messages
        function handleWebSocketMessage(message) {
            switch (message.type) {
                case 'fullSnapshot':
                    handleFullSnapshot(message);
                    break;
                case 'deltaUpdate':
                    handleDeltaUpdate(message);
                    break;
                case 'sourceRemoved':
                    handleSourceRemoved(message);
                    break;
                default:
                    console.warn('Unknown message type:', message.type);
            }
        }

        // Handle full snapshot message
        function handleFullSnapshot(message) {
            console.log('Received full snapshot:', message);
            sources = {};

            if (message.sources && typeof message.sources === 'object') {
                // Iterate through categories (keys like "GPS", "Compass", etc.)
                Object.keys(message.sources).forEach(categoryName => {
                    const categoryData = message.sources[categoryName];

                    // Iterate through message types (keys like "PGN129025", "RSA", etc.)
                    Object.keys(categoryData).forEach(messageTypeId => {
                        const sourcesArray = categoryData[messageTypeId];

                        // Iterate through sources in this message type
                        if (Array.isArray(sourcesArray)) {
                            sourcesArray.forEach(source => {
                                // Create unique key combining sourceId and messageTypeId
                                // This prevents sources with same ID but different message types from overwriting each other
                                const key = `${source.sourceId}-${messageTypeId}`;
                                sources[key] = {
                                    ...source,
                                    category: categoryName,
                                    messageTypeId: messageTypeId
                                };
                            });
                        }
                    });
                });
            }

            renderAllSources();
        }

        // Handle delta update message
        function handleDeltaUpdate(message) {
            console.log('Received delta update:', message);

            if (message.changes && Array.isArray(message.changes)) {
                message.changes.forEach(change => {
                    // Since delta updates only include sourceId (not messageTypeId),
                    // we need to update all sources that match this sourceId
                    let updated = false;
                    Object.keys(sources).forEach(key => {
                        if (sources[key].sourceId === change.sourceId) {
                            // Update existing source
                            if (change.frequency !== undefined) sources[key].frequency = change.frequency;
                            if (change.timeSinceLast !== undefined) sources[key].timeSinceLast = change.timeSinceLast;
                            if (change.isStale !== undefined) sources[key].isStale = change.isStale;
                            if (change.deviceInfo !== undefined) sources[key].deviceInfo = change.deviceInfo;

                            updateSourceRow(sources[key]);
                            updated = true;
                        }
                    });

                    if (!updated) {
                        // New source discovered in delta (shouldn't happen but handle it)
                        console.warn('New source discovered in delta update:', change.sourceId);
                        // We need category and messageTypeId to render properly
                        // For now, just log a warning - fullSnapshot should provide these
                    }
                });
            }

            updateSummary();
        }

        // Handle source removed message
        function handleSourceRemoved(message) {
            console.log('Source removed:', message);
            // Remove all sources with matching sourceId (may be multiple with different message types)
            let removed = false;
            Object.keys(sources).forEach(key => {
                if (sources[key].sourceId === message.sourceId) {
                    delete sources[key];
                    removed = true;
                }
            });

            if (removed) {
                renderAllSources();
            }
        }

        // Render all sources organized by category
        function renderAllSources() {
            const container = document.getElementById('categoriesContainer');
            const loadingIndicator = document.getElementById('loadingIndicator');

            if (Object.keys(sources).length === 0) {
                loadingIndicator.style.display = 'block';
                container.innerHTML = '';
                updateSummary();
                return;
            }

            loadingIndicator.style.display = 'none';

            // Group sources by category
            const categorizedSources = {};
            Object.values(sources).forEach(source => {
                const cat = source.category || 'UNKNOWN';
                if (!categorizedSources[cat]) {
                    categorizedSources[cat] = [];
                }
                categorizedSources[cat].push(source);
            });

            // Render each category
            let html = '';
            Object.keys(categorizedSources).sort().forEach(category => {
                const categoryDisplayName = categoryNames[category] || category;
                const categorySources = categorizedSources[category];

                html += `
                    <div class="category-section">
                        <div class="category-header" onclick="toggleCategory('${category}')">
                            <span class="category-title">${categoryDisplayName}</span>
                            <span class="category-badge">${categorySources.length}</span>
                        </div>
                        <div class="category-content active" id="category-${category}">
                            <table class="sources-table">
                                <thead>
                                    <tr>
                                        <th>Source ID</th>
                                        <th>Message Type</th>
                                        <th>Protocol</th>
                                        <th>Device Info</th>
                                        <th>Frequency</th>
                                        <th>Time Since Last</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody id="tbody-${category}">
                                    ${renderCategorySources(categorySources)}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
            updateSummary();
        }

        // Format device info for display
        function formatDeviceInfo(source) {
            if (!source.deviceInfo) {
                return '<span class="device-unknown">—</span>';
            }

            const info = source.deviceInfo;

            // NMEA2000 source with full device info
            if (info.hasInfo) {
                return `
                    <div class="device-info-container">
                        <div class="device-primary">
                            <strong>${info.manufacturer}</strong> ${info.modelId}
                        </div>
                        <div class="device-secondary">
                            SN: ${info.serialNumber} | SW: ${info.softwareVersion}
                        </div>
                    </div>
                `;
            }

            // NMEA0183 source with talker description
            if (info.description) {
                return `<span class="device-description">${info.description}</span>`;
            }

            // Status messages (Discovering, Timeout, etc.)
            if (info.status) {
                const statusClass = info.status.includes('timeout') ? 'device-timeout' : 'device-discovering';
                return `<span class="${statusClass}">${info.status}</span>`;
            }

            return '<span class="device-unknown">—</span>';
        }

        // Render sources for a specific category
        function renderCategorySources(categorySources) {
            return categorySources.map(source => {
                const protocolClass = source.protocol === 'NMEA2000' ? 'protocol-nmea2000' : 'protocol-nmea0183';
                const stalenessClass = source.isStale ? 'stale' : 'fresh';
                const stalenessText = source.isStale ? 'Stale' : 'Active';
                const frequencyDisplay = source.frequency > 0 ? `${source.frequency.toFixed(2)} Hz` : '—';
                const timeSinceDisplay = `${(source.timeSinceLast / 1000).toFixed(1)}s`;
                // Create unique row identifier combining sourceId and messageTypeId
                const uniqueId = `${source.sourceId}-${source.messageTypeId}`;

                return `
                    <tr data-source-key="${uniqueId}">
                        <td data-label="Source ID" class="source-id">${source.sourceId}</td>
                        <td data-label="Message Type" class="message-type">${source.messageTypeId}</td>
                        <td data-label="Protocol">
                            <span class="protocol-badge ${protocolClass}">${source.protocol}</span>
                        </td>
                        <td data-label="Device Info" class="device-info-cell">${formatDeviceInfo(source)}</td>
                        <td data-label="Frequency" class="frequency">${frequencyDisplay}</td>
                        <td data-label="Time Since Last" class="time-since">${timeSinceDisplay}</td>
                        <td data-label="Status">
                            <div class="staleness-indicator">
                                <div class="staleness-dot ${stalenessClass}"></div>
                                <span class="staleness-text ${stalenessClass}">${stalenessText}</span>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        // Update a single source row
        function updateSourceRow(source) {
            // Create unique row identifier combining sourceId and messageTypeId
            const uniqueId = `${source.sourceId}-${source.messageTypeId}`;
            const row = document.querySelector(`tr[data-source-key="${uniqueId}"]`);
            if (!row) return;

            const stalenessClass = source.isStale ? 'stale' : 'fresh';
            const stalenessText = source.isStale ? 'Stale' : 'Active';
            const frequencyDisplay = source.frequency > 0 ? `${source.frequency.toFixed(2)} Hz` : '—';
            const timeSinceDisplay = `${(source.timeSinceLast / 1000).toFixed(1)}s`;

            // Update frequency
            const freqCell = row.querySelector('.frequency');
            if (freqCell) freqCell.textContent = frequencyDisplay;

            // Update time since last
            const timeCell = row.querySelector('.time-since');
            if (timeCell) timeCell.textContent = timeSinceDisplay;

            // Update staleness indicator
            const stalenessIndicator = row.querySelector('.staleness-indicator');
            if (stalenessIndicator) {
                stalenessIndicator.innerHTML = `
                    <div class="staleness-dot ${stalenessClass}"></div>
                    <span class="staleness-text ${stalenessClass}">${stalenessText}</span>
                `;
            }
        }

        // Update summary cards
        function updateSummary() {
            const totalSources = Object.keys(sources).length;
            const activeSources = Object.values(sources).filter(s => !s.isStale).length;
            const staleSources = totalSources - activeSources;

            const categories = new Set(Object.values(sources).map(s => s.category));
            const activeCategories = categories.size;

            document.getElementById('totalSources').textContent = totalSources;
            document.getElementById('activeSources').textContent = activeSources;
            document.getElementById('staleSources').textContent = staleSources;
            document.getElementById('activeCategories').textContent = activeCategories;
        }

        // Toggle category visibility
        function toggleCategory(category) {
            const content = document.getElementById(`category-${category}`);
            if (content) {
                content.classList.toggle('active');
            }
        }

        // Update connection status indicator
        function updateConnectionStatus(text, connected) {
            const indicator = document.getElementById('connectionIndicator');
            const textElement = document.getElementById('connectionText');

            textElement.textContent = text;
            if (connected) {
                indicator.classList.add('connected');
            } else {
                indicator.classList.remove('connected');
            }
        }

        // Attempt to reconnect WebSocket
        function attemptReconnect() {
            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                console.error('Max reconnect attempts reached');
                updateConnectionStatus('Failed to connect', false);
                return;
            }

            reconnectAttempts++;
            console.log(`Reconnecting... (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
            updateConnectionStatus(`Reconnecting (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`, false);

            setTimeout(() => {
                connectWebSocket();
            }, RECONNECT_DELAY);
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            connectWebSocket();
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (ws) {
                ws.close();
            }
        });
    </script>
</body>
</html>
